// https://stackoverflow.com/a/50375286
type UnionToIntersection<U> = (U extends any ? (u: U) => void : never) extends ((u: infer I) => void) ? I : never;

type UndefinedToOptional<T> = UnionToIntersection<
  {
    [K in keyof T]: (
      T[K] extends undefined
        ? {}
        : undefined extends T[K]
          ? {[key in K]?: T[K]}
          : {[key in K]: T[K]}
    )
  }[keyof T]
>;

type Primitive = bigint | boolean | null | number | string | symbol;

function isPrimitive(input: unknown): input is Primitive {
  switch (typeof input) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "symbol":
      return true;
    case "object":
      return input === null;
    default:
      return false;
  }
}

function reprPrimitive(value: Primitive): string {
  switch (typeof value) {
    case "bigint":
      return value.toString() + "n";
    case "string":
      return JSON.stringify(value);
    case "symbol":
      return value.toString();
    default:
      return "" + value;
  }
}


/*
paths
error messages at leaves
step of the union/chain?
*/

type TransformFunc<I, O, E = unknown> = (input: I) => O;

type Predicate<I> = (input: I) => boolean | string;

function wrapPredicate<I>(predicate: Predicate<I>): TransformFunc<I, I> {
  return (input) => {
    const result = predicate(input);
    if (typeof result === "string") {
      throw new Error(result);
    }
    else if (!result) {
      throw new Error();
    }
    return input;
  }
}

type TransformSpec = Primitive | TransformFunc<unknown, unknown> | TupleSpec | ObjectSpec;

interface ObjectSpec {
  readonly [key: string]: TransformSpec;
}

type TupleSpec = readonly [] | readonly [TransformSpec, ...TransformSpec[]];

// TODO: instead of Function, use () => void?

type test = ((a: number) => number) extends AnyFunction ? true : false;
type test2 = (() => boolean) extends AnyFunction ? true : false;

type AnyFunction = (...args: any[]) => void;

type NarrowestInput<S> = (
  S extends Primitive
  ? S
  : S extends TransformFunc<infer I, infer O, infer E>
    ? I & E /*
      : S extends AnyFunction
        ? never */
        : S extends TupleSpec
          ? {readonly [K in keyof S]: K extends keyof [] ? S[K] : NarrowestInput<S[K]>}
          : S extends ObjectSpec
            ? UndefinedToOptional<{readonly [K in keyof S]: NarrowestInput<S[K]>}>
            : never
);

type WidestInput<S> = (
  S extends Primitive
  ? unknown
  : S extends TransformFunc<infer I, infer O, infer E>
    ? I /*
      : S extends AnyFunction
        ? never */
        : S extends TupleSpec
          ? unknown
          : S extends ObjectSpec
            ? unknown
            : never
);

type Output<S> = (
  S extends Primitive
    ? S
    : S extends TransformFunc<infer I, infer O, infer E>
      ? O /*
      : S extends AnyFunction
        ? never */
        : S extends TupleSpec
          ? {-readonly [K in keyof S]: K extends keyof [] ? S[K] : Output<S[K]>}
          : S extends ObjectSpec
            ? UndefinedToOptional<{-readonly [K in keyof S]: Output<S[K]>}>
            : never
);

function transformPrimitive<S extends Primitive>(input: WidestInput<S>, spec: S): Output<S> {
  if (input === spec) {
    return spec as Output<S>;
  }
  throw new Error(`Not equal to ${reprPrimitive(spec)}`);
}

function transformTuple<S extends TupleSpec>(input: WidestInput<S>, spec: S): Output<S> {
  if (!Array.isArray(input)) {
    throw new Error("Not an array");
  }
  if (input.length !== spec.length) {
    throw new Error(`Length is not ${spec.length}`);
  }

  // @ts-ignore
  const transformed = [] as Output<S>;
  for (let i = 0; i < spec.length; i++) {
    try {
      const transformedValue = transform(input[i], spec[i]);
      // @ts-ignore
      transformed.append(transformedValue);
    } catch (e) {
      throw e;
    }
  }
  return transformed;
}

function transformObject<S extends ObjectSpec>(input: WidestInput<S>, spec: S): Output<S> {
  if (typeof input !== "object" || input === null) {
    throw new Error("Not an object");
  }

  for (const key of Object.getOwnPropertyNames(input)) {
    if (!(key in spec)) {
      throw new Error(`Unrecognized key: ${reprPrimitive(key)}`);
    }
  }

  const transformed = {} as Output<S>;
  for (const key of Object.getOwnPropertyNames(spec)) {
    const inputValue: unknown = (input as any)[key];
    try {
      const transformedValue = transform(inputValue, spec[key]);
      if (transformedValue !== undefined) {
        // @ts-ignore
        transformed[key] = transformedValue;
      }
    } catch (e) {
      throw e;
    }
  }

  return transformed;
}

/*

interface OneTransformError {
  error: string;
}

interface ManyTransformErrors {
  errors: string[];
}

interface NestedTransformErrors {
  fields: {
    [key: string]: OneTransformError | ManyTransformErrors | NestedTransformErrors;
  };
}

*/


/*
{
  hi: number,
  bye: number,
  razzle: [string, string],
  baz: validateNumber({ min: 3, integer: true }),
}
{
  type: "object",
  fields: {
    hi: {
      type: "function",
      name: "number"
    },
    bye: {
      type: "function",
      name: "string"
    },
    razzle: {
      type: "array",
      elements: [
        {
          type: "function",
          name: "string"
        },
        {
          type: "function",
          name: "string"
        },
      ]
    },
    baz: {
      type: "call",
      function: "validateNumber",
      arguments: [
        {
          type: "object",
          fields: {
            min: {
              type: "number",
              value: 3,
            },
            integer: {
              type: "boolean",
              value: true,
            }
          }
        }
      ]
    }
  },
}
{
  hi: "number",
  bye: "number",
  razzle: ["tuple", ["list", "string", "string"]],
  baz: ["validateNumber", { min: 3, integer: true }]
}
{
  hi: 3,
  bye: "there",
  razzle: ["oops", 7],
  baz: 2.5,
  huh: "extra",
}
{
  fields: {
    bye: {
      "error": "Not a number"
    },
    razzle: {
      fields: {
        "1": {
          "error": "Not a string"
        }
      }
    },
    baz: {
      "errors": ["Less than the minimum of 3", "Not an integer"]
    }
    huh: {
      "error": "Unrecognized key"
    }
  }
}
*/

function transform<S extends TransformSpec>(input: WidestInput<S>, spec: S): Output<S> {
  if (isPrimitive(spec)) {
    return transformPrimitive(input, spec) as Output<S>;
  }
  if (typeof spec === "function") {
    return spec(input) as Output<S>;
  }
  if (Array.isArray(spec)) {
    return transformTuple(input, spec as TupleSpec) as Output<S>;
  }
  return transformObject(input, spec as ObjectSpec) as Output<S>;
}

function compile<S extends TransformSpec>(spec: S): TransformFunc<WidestInput<S>, Output<S>, NarrowestInput<S>> {
  return (input) => transform(input, spec);
}

const boolean: TransformFunc<unknown, boolean, boolean> = (input) => {
  if (typeof input === "boolean") {
    return input;
  } else {
    throw new Error("Not a boolean");
  }
}

const number: TransformFunc<unknown, number, number> = (input, options?: NumberValidationOptions) => {
  if (typeof input !== "number") {
    throw new Error("Not a number");
  }
  if (options !== undefined) {
    const { min, max, integer, finite } = options;
    if (finite !== undefined) {
      const isFinite = Number.isFinite(input);
      if (isFinite !== finite) {
        throw new Error();
      }
    }
    if (integer !== undefined) {
      const isInteger = Math.round(input) === input;
      if (isInteger !== integer) {
        throw new Error();
      }
    }
    if (min !== undefined && input < min) {
      throw new Error();
    }
    if (max !== undefined && input > max) {
      throw new Error();
    }
  }
  return input;
}

const string: TransformFunc<unknown, string, string> = (input) => {
  if (typeof input === "string") {
    return input;
  }
  throw new Error("Not a string");
}

const unknown: TransformFunc<unknown, unknown> = (input) => input;

function replaceWith<T>(value: T): TransformFunc<unknown, T> {
  return (input) => value;
}

const remove = replaceWith(undefined);

const placeholder = ((input) => {
  throw new Error("Placeholder not replaced");
}) as TransformSpec;

function optional<S extends TransformSpec>(spec: S): TransformFunc<WidestInput<S> | undefined, Output<S> | undefined, NarrowestInput<S> | undefined> {
  return (input) => {
    if (input === undefined) {
      return undefined;
    }
    return transform(input, spec);
  };
}

function nullable<S extends TransformSpec>(spec: S): TransformFunc<WidestInput<S> | null, Output<S> | null, NarrowestInput<S> | null> {
  return (input) => {
    if (input === null) {
      return null;
    }
    return transform(input, spec);
  }
}

function union<S extends readonly [TransformSpec, ...TransformSpec[]]>(...specs: S): TransformFunc<
    unknown,
    Output<S>[number],
    // @ts-ignore
    NarrowestInput<S>[number],
> {
  return (input) => {
    for (let i = 0; i < specs.length; i++) {
      try {
        return transform(input, specs[i]);
      } catch (e) {
        throw e;
      }
    }
  }
}

type RecursiveTransformerUnion<I, O, E, S> = (
  S extends readonly []
  ? [I, O, E]
  : S extends readonly [infer T, ...infer R]
    ? T extends TransformFunc<infer J, infer P, infer F>
      ? RecursiveTransformerUnion<I & WidestInput<T>, O | Output<T>, E | NarrowestInput<T>, R>
      : never
    : never
);

type TransformerUnion<S> = RecursiveTransformerUnion<unknown, never, never, S>;

function transformerUnion<S extends [Function, ...Function[]]>(...transformers: S): TransformFunc<TransformerUnion<S>[0], TransformerUnion<S>[1], TransformerUnion<S>[2]> {
  return (input) => {
    for (let i = 0; i < transformers.length; i++) {
      try {
        return transformers[i](input);
      } catch (e) {
        throw e;
      }
    }
    throw new Error();
  }
}

const frob = transformerUnion((x: string) => x);
const aoeu = transformerUnion((x: string) => x + "nice", (y: unknown) => 3);

type RecursiveTransformerChain<I, O, E, S> = (
  S extends readonly []
    ? [I, O, E]
    : S extends readonly [infer T, ...infer R]
      ? T extends TransformFunc<O, infer P>
        ? RecursiveTransformerChain<I, P, E, R>
        : never
      : never
);

type TransformerChain<S> = (
  S extends [infer T, ...infer R]
    ? T extends TransformFunc<infer I, infer O>
      ? RecursiveTransformerChain<WidestInput<T>, Output<T>, NarrowestInput<T>, R>
      : never
    : never
);

function transformerChain<S extends [Function, ...Function[]]>(...transformers: S): TransformFunc<TransformerChain<S>[0], TransformerChain<S>[1], TransformerChain<S>[2]> {
  return (input) => {
    for (const transformer of transformers) {
      input = transformer(input);
    }
    return input;
  }
}

type Chain<S extends TransformSpec, T extends Function[]> = TransformerChain<[TransformFunc<WidestInput<S>, Output<S>, NarrowestInput<S>>, ...T]>;

function chain<S extends TransformSpec, T extends Parameters<typeof transformerChain>>(spec: S, ...transformers: T): TransformFunc<Chain<S, T>[0], Chain<S, T>[1], Chain<S, T>[2]> {
  return (input) => {
    let result = transform(input, spec);
    for (const transformer of transformers) {
      result = transformer(input);
    }
    return result as any;
  }
}

// two styles: pass in input only (Transformer), or pass in input and validation options... make validation options an optional argument?
// number, asNumber(options): Transformer<unknown, number, number>
// validateNumber: (unknown) => as
// 

// function validateNumber()

function asArrayOf<S extends TransformSpec>(elementSpec: S, options?: ArrayValidationOptions): TransformFunc<unknown, Output<S>[], NarrowestInput<S>[]> {
  return (input) => {
    if (!Array.isArray(input)) {
      throw new Error("Not an array");
    }
    if (options?.length !== undefined) {
      number(input.length);
    };
    const transformed = [];
    for (let i = 0; i < input.length; i++) {
      try {
        transformed.push(transform(input[i], elementSpec));
      } catch (e) {
        throw e;
      }
    }
    return transformed;
  }
}

// type PartialSpec<S> = { [K in keyof S]: Transformer<unknown, Output<S[K]> | undefined, NarrowestInput<S[K]> | undefined> };
type PartialSpec<S> = { [K in keyof S]: TransformFunc<unknown, Output<S[K]> | undefined, NarrowestInput<S[K]> | undefined> };

function partial<S extends ObjectSpec>(spec: S): PartialSpec<S> {
  const result = {} as PartialSpec<S>;
  for (const k of Object.getOwnPropertyNames(spec)) {
    const key: keyof S = k;
    const valueSpec = spec[key];
    if (valueSpec !== undefined) {
      result[key] = optional(valueSpec) as PartialSpec<S>[keyof S];
    }
  }
  return result as PartialSpec<S>;
}

function omit<S extends ObjectSpec, T extends [keyof S, ...(keyof S)[]]>(spec: S, ...keys: T): {[K in Exclude<keyof S, T[number]>]: S[K]} {
  const result = {...spec};
  for (const key of keys) {
    delete result[key];
  }
  return result;
}

function pick<S extends ObjectSpec, T extends [keyof S, ...(keyof S)[]]>(spec: S, ...keys: T): {[K in T[number]]: S[K]} {
  const result: Partial<S> = {};
  for (const key of keys) {
    result[key] = spec[key];
  }
  return result as {[K in T[number]]: S[K]};
}

function narrow<S extends TransformSpec>(spec: S): TransformFunc<NarrowestInput<S>, Output<S>> {
  if (typeof spec === "function") {
    return spec as TransformFunc<NarrowestInput<S>, Output<S>>;
  }
  return compile(spec);
}

interface RestTupleSpec {
  elements: TupleSpec,
  rest: TransformSpec,
}

const specNumberValidationOptions = {
  min: optional(number),
  max: optional(number),
  integer: optional(boolean),
  finite: optional(boolean),
}

type NumberValidationOptions = Output<typeof specNumberValidationOptions>;

interface ArrayValidationOptions {
  length: number | NumberValidationOptions,
}

function wrap<S extends TupleSpec, R>(spec: S, func: (...args: Output<S>) => R): (...args: NarrowestInput<S>) => R {
  return (...args) => func(...transform(args, spec));
}

/* basically just chain
function checkedFunction<S extends TupleSpec, R>(spec: S, func: (args: Output<S>) => R): (args: WidestInput<S>) => R {
  return (input) => func(transform(input, spec));
}
*/

const banana = transformerChain((x: string) => x + "hi", (y: number) => y + 3);

const fooSpec = {
  baz: union(string, number, optional(boolean)),
  test: union(number, string),
  rad: transformerUnion/*<unknown, number | string | boolean, number | string | boolean>*/(number, string, boolean),
  // brob: transformerUnion<string, number | Date>((x: string) => parseInt(x), (x: string) => new Date(x)),
};
const test: ObjectSpec = fooSpec;

type FooWide = WidestInput<typeof fooSpec>;
type FooNarrow = NarrowestInput<typeof fooSpec>;
type FooOutput = Output<typeof fooSpec>;

const linkedListSpec = {
  value: chain(number, (x: number) => x + 1, (y: number) => y + "hi"),
  baz: chain([number, number], transformerChain((([x, y]: [number, number]) => x + y), ((z: number) => z + 3))),
  next: placeholder,
}

linkedListSpec.next = optional(linkedListSpec);

type LinkedListInput = NarrowestInput<typeof linkedListSpec> & {
  readonly next?: LinkedListInput;
};

type LinkedListOutput = Output<typeof linkedListSpec> & {
  next?: LinkedListOutput;
}

const transformLinkedList = compile(linkedListSpec) as TransformFunc<unknown, LinkedListOutput, LinkedListInput>;

const thing: LinkedListInput = {
  value: 5,
  baz: [3, 9],
  next: {
    value: 7,
    baz: [2, 4],
  },
};

const numberValidationSpec = {
  min: optional(number),
  // max: optional(number),
  // integer: optional(boolean),
  real: asArrayOf(boolean),
  nice: remove,
  awesome: replaceWith(7),
  nested: placeholder,
};

const partialNumberValidationSpec = partial(numberValidationSpec);

type bazn = typeof partialNumberValidationSpec;

numberValidationSpec.nested = optional(numberValidationSpec);

type NumberValidationInput = NarrowestInput<typeof numberValidationSpec>;
type NumberValidationOutput = Output<typeof numberValidationSpec>;

type PartialNumberValidationInput = NarrowestInput<typeof partialNumberValidationSpec>;
type PartialNumberValidationOutput = Output<typeof partialNumberValidationSpec>;

type MinValidation = Output<typeof numberValidationSpec["min"]>;

type NumberValidation = Output<typeof numberValidationSpec>;
type bar = NumberValidation["min"];

type baz = NarrowestInput<typeof numberValidationSpec>;

type Test = {
  a: boolean;
  b: number | undefined;
}

function validatedNumber(options: NumberValidationInput): TransformFunc<unknown, number> {
  return (input) => {
    const num = number(input);
    if (options.min !== undefined && !(options.min <= num)) {
      throw new Error("Too large");
    }
    // TODO remaining conditions
    return num;
  };
}

const foo = validatedNumber({ real: [false] })(7);

export {
  boolean,
  number,
  string,
  unknown,
  transform,
  union,
  chain,
  compile,
  partial,
  omit,
  pick,
  remove,
  replaceWith,
  narrow,
  placeholder,
  TransformFunc as Transformer,
  TransformSpec,
  Output,
  WidestInput,
  NarrowestInput,
}
