// // type KeyTuple<T> = [] | [keyof T, ...(keyof T)[]];
// // type PickedEntries<T, S extends KeyTuple<T>> = { [K in keyof S]: K extends number ? T[S[K]] : K extends keyof readonly [] ? [][K] : never };

// /*
// type PickResult<T, K extends KeyTuple<T>> = (
//   K extends []
//     ? {}
//     : K extends [infer F, ...infer R]
//       ? F extends keyof T
//         ? R extends KeyTuple<T>
//           ? { [key: F]: T[F] } & PickResult<T, R>
//           : never
//         : never
//       : never
// );
// */

// // type PickResult<T, S extends KeyTuple<T>> = { [K in keyof T]: K extends S[number] ? T[K] : never };

// type KeyTuple<T, F extends keyof T, R extends (keyof T)[]> = [F, ...R];

// function pick<T, S extends KeyTuple<T>>(obj: T, ...keys: S): PickResult<T, S> {
//   // const entries: PickedEntries<T, S> = keys.map((key: S[number]) => [key, obj[key]] as const);
//   const picked = {} as PickResult<T, S>;
//   for (const key of keys) {
//     picked[key] = obj[key] as any;
//   }
//   return picked;

//   /*
//   for (const key of keys) {
//     picked[key] = obj[key];
//   }
//   */

//   /*
//   for (let i = 0; i < keys.length; i++) {
//     const key: S[number] & keyof T = keys[i];
//     picked[key] = obj[key];
//   }
//   */
// }

// const bar = pick({"hi": 3, "bye": false}, ...(["hi"] as const));

// if(!bar.bye) {

// }

// function recursivePick<T, S extends KeyTuple<T>, P>(obj: T, picked: PickResult<T, S>, key: keyof T, ...keys: S) {
//   /*
//   picked[key] = obj[key];
//   if (keys.length === 0) {

//   }
//   */
// }

// type KeyTuple()

/**
 * 
 * @param obj 
 * @param keys 
 * @returns 
 * @see https://stackoverflow.com/a/47232883
 */
function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K> {
  const picked = {} as Pick<T, K>;
  for (const key of keys) {
    picked[key] = obj[key];
  }
  return picked;
}

const o = {a: 1, b: '2', c: 3}
const picked = pick(o, 'b', 'c');
picked.b
